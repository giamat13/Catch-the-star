<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>×ª×¤×•×¡ ××ª ×”×›×•×›×‘×™× - 20 ×©×œ×‘×™×</title>
    <style>
        body {
            margin: 0;
            padding: 10px;
            background: linear-gradient(135deg, #1e3c72, #2a5298, #1a237e);
            font-family: Arial, sans-serif;
            color: white;
            overflow: hidden;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        #gameContainer {
            position: relative;
            width: 100%;
            height: calc(100vh - 200px);
            min-height: 400px;
            max-height: 800px;
            border: 3px solid #fff;
            border-radius: 15px;
            background: radial-gradient(circle at center, #0f1419, #1a237e);
            overflow: hidden;
            cursor: crosshair;
            flex-grow: 1;
        }
        
        #gameInfo {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 14px;
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 10px;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .info-section {
            text-align: center;
            flex: 1;
            min-width: 100px;
        }
        
        #globalLevel {
            background: linear-gradient(45deg, #ff6b35, #f7931e);
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            font-weight: bold;
            font-size: 18px;
            text-align: center;
            margin-bottom: 8px;
            border: 2px solid #fff;
            box-shadow: 0 0 15px rgba(255,107,53,0.5);
        }
        
        #stageInfo {
            text-align: center;
            background: rgba(0,0,0,0.5);
            padding: 15px;
            margin-bottom: 8px;
            border-radius: 10px;
            border: 2px solid #4caf50;
        }
        
        #legend {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin-bottom: 8px;
            font-size: 11px;
            opacity: 0.9;
            flex-wrap: wrap;
            background: rgba(0,0,0,0.3);
            padding: 8px;
            border-radius: 8px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 3px;
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            margin: 10px 0;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4caf50, #8bc34a);
            border-radius: 10px;
            transition: width 0.3s ease;
            position: relative;
        }
        
        .progress-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 12px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        
        .star {
            position: absolute;
            font-size: 30px;
            cursor: pointer;
            transition: transform 0.1s;
            animation: twinkle 1.5s infinite alternate;
        }
        
        .star-regular { color: #ffeb3b; }
        .star-blue { color: #4169e1; font-size: 28px; }
        .star-silver { color: #c0c0c0; font-size: 32px; }
        .star-gold { color: #ffd700; font-size: 35px; }
        .star-rainbow { 
            font-size: 40px; 
            animation: rainbow 2s infinite linear, twinkle 1.5s infinite alternate; 
        }
        
        .bomb, .blackhole, .lightning {
            position: absolute;
            cursor: pointer;
        }
        
        .bomb {
            font-size: 25px;
            animation: rotate 2s infinite linear;
        }
        
        .blackhole {
            font-size: 28px;
            animation: blackholeRotate 3s infinite ease-in-out, blackholePulse 1.5s infinite alternate;
        }
        
        .lightning {
            font-size: 22px;
            animation: lightningZigzag 2s infinite linear, lightningGlow 0.5s infinite alternate;
        }
        
        .powerup {
            position: absolute;
            font-size: 30px;
            cursor: pointer;
            animation: pulse 1s infinite alternate;
        }
        
        #player {
            position: absolute;
            font-size: 40px;
            pointer-events: none;
            z-index: 10;
        }
        
        .player-shield {
            box-shadow: 0 0 20px #2196f3;
            animation: shieldGlow 1s infinite alternate;
        }
        
        #gameOver, #stageComplete, #levelComplete {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            border: 2px solid #ffeb3b;
            display: none;
            z-index: 100;
            max-height: 90vh;
            max-width: 90vw;
            overflow-y: auto;
        }
        
        #stageComplete { border-color: #4caf50; }
        #levelComplete { border-color: #ff6b35; }
        
        button {
            background: #4caf50;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            margin: 8px;
            transition: background 0.3s;
            min-height: 44px;
        }
        
        button:hover { background: #45a049; }
        
        .retry-btn { background: #ff9800; }
        .retry-btn:hover { background: #f57c00; }
        
        .reset-btn { background: #f44336; }
        .reset-btn:hover { background: #d32f2f; }
        
        .mega-btn {
            background: linear-gradient(45deg, #ff6b35, #f7931e);
            font-weight: bold;
        }
        
        .points-text, .combo-text {
            position: absolute;
            font-weight: bold;
            font-size: 18px;
            pointer-events: none;
            animation: floatUp 1s ease-out forwards;
            z-index: 50;
        }
        
        .combo-text { color: #4caf50; font-size: 20px; }
        .points-text { color: #ffeb3b; }
        
        @keyframes rainbow {
            0% { filter: hue-rotate(0deg); }
            100% { filter: hue-rotate(360deg); }
        }
        
        @keyframes twinkle {
            0% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        
        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            100% { transform: scale(1.1); }
        }
        
        @keyframes blackholeRotate {
            0% { transform: rotate(0deg) scale(1); }
            50% { transform: rotate(180deg) scale(1.1); }
            100% { transform: rotate(360deg) scale(1); }
        }
        
        @keyframes blackholePulse {
            0% { filter: brightness(0.8) hue-rotate(0deg); }
            100% { filter: brightness(1.2) hue-rotate(20deg); }
        }
        
        @keyframes lightningZigzag {
            0% { transform: translateX(0) rotate(0deg); }
            25% { transform: translateX(3px) rotate(5deg); }
            50% { transform: translateX(-3px) rotate(-5deg); }
            75% { transform: translateX(2px) rotate(3deg); }
            100% { transform: translateX(0) rotate(0deg); }
        }
        
        @keyframes lightningGlow {
            0% { filter: brightness(1) drop-shadow(0 0 5px #ff5722); }
            100% { filter: brightness(1.3) drop-shadow(0 0 10px #ff9800); }
        }
        
        @keyframes shieldGlow {
            0% { box-shadow: 0 0 20px #2196f3; }
            100% { box-shadow: 0 0 30px #64b5f6; }
        }
        
        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-40px); }
        }
        
        @media (max-width: 768px) {
            body { 
                padding: 3px; 
            }
            
            #gameContainer {
                height: calc(100vh - 140px);
                border-width: 1px;
                min-height: 250px;
            }
            
            .info-section {
                min-width: 70px;
                font-size: 9px;
            }
            
            #gameInfo {
                flex-direction: row;
                gap: 3px;
                padding: 4px;
            }
            
            #globalLevel {
                font-size: 12px;
                padding: 4px 8px;
            }
            
            #stageInfo {
                padding: 6px;
            }
            
            #legend {
                gap: 3px;
                font-size: 8px;
                padding: 4px;
            }
            
            button {
                font-size: 11px;
                padding: 6px 10px;
                margin: 3px;
                min-height: 32px;
            }
            
            #gameOver, #stageComplete, #levelComplete {
                padding: 10px;
                font-size: 10px;
                max-width: 98vw;
                margin: 1vw;
            }
        }
        
        @media (max-width: 480px) {
            #gameContainer {
                height: calc(100vh - 120px);
                min-height: 200px;
            }
            
            #gameInfo .info-section {
                min-width: 60px;
                font-size: 8px;
            }
            
            #legend {
                font-size: 7px;
                gap: 2px;
            }
            
            .legend-item {
                margin: 1px;
            }
        }
    </style>
</head>
<body>
    <div id="globalLevel">×¨××” ×’×œ×•×‘×œ×™×ª: 1 (××›×¤×™×œ × ×§×•×“×•×ª: x1)</div>
    
    <div id="legend">
        <div class="legend-item">â­ ×¨×’×™×œ (5Ã—×¨××”)</div>
        <div class="legend-item">ğŸŒŸ ×›×—×•×œ (10Ã—×¨××”)</div>
        <div class="legend-item">ğŸ’« ×›×¡×£ (20Ã—×¨××”)</div>
        <div class="legend-item">ğŸŒ  ×–×”×‘ (50Ã—×¨××”)</div>
        <div class="legend-item">ğŸ† ×§×©×ª (100Ã—×¨××”)</div>
        <div class="legend-item">ğŸ›¡ï¸ ××’×Ÿ</div>
        <div class="legend-item">â¤ï¸ ×—×™×™×</div>
        <div class="legend-item">âš¡ ××”×™×¨×•×ª</div>
        <div class="legend-item" id="freezeLegend" style="opacity: 0.5;">â„ï¸ ×”×§×¤××” (×¨××” 2+)</div>
        <div class="legend-item" id="magnetLegend" style="opacity: 0.5;">ğŸ§² ××’× ×˜ (×¨××” 3+)</div>
        <div class="legend-item" id="doubleLegend" style="opacity: 0.5;">ğŸ’ ×›×¤×•×œ (×¨××” 4+)</div>
        <div class="legend-item" style="color: #f44336;">ğŸ’¥ ×¤×¦×¦×”</div>
        <div class="legend-item" style="color: #9c27b0;">ğŸ•³ï¸ ×—×•×¨ ×©×—×•×¨</div>
        <div class="legend-item" style="color: #ff5722;">â›ˆï¸ ×–×™×§</div>
    </div>
    
    <div id="stageInfo">
        <div id="stageTitle">×©×œ×‘ 1: ×”×ª×—×œ×”</div>
        <div id="stageGoal">×™×¢×“: 100 × ×§×•×“×•×ª</div>
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill" style="width: 0%">
                <div class="progress-text" id="progressText">0 / 100</div>
            </div>
        </div>
    </div>
    
    <div id="gameInfo">
        <div class="info-section">
            <div>× ×§×•×“×•×ª: <span id="score">0</span></div>
            <div>×§×•××‘×•: <span id="combo">x1</span></div>
        </div>
        <div class="info-section">
            <div>×—×™×™×: <span id="lives">3</span></div>
            <div>×©×œ×‘: <span id="stageNum">1</span>/20</div>
        </div>
        <div class="info-section">
            <div>××’×Ÿ: <span id="shield">0</span></div>
            <div>××™×•×—×“: <span id="special">××™×Ÿ</span></div>
        </div>
    </div>
    
    <div id="gameContainer">
        <div id="player">ğŸ¯</div>
        
        <div id="gameOver">
            <h2>× ×›×©×œ×ª ×‘×©×œ×‘!</h2>
            <p>× ×™×§×•×“: <span id="failScore">0</span> ××ª×•×š <span id="failTarget">0</span></p>
            <button class="retry-btn" onclick="retryStage()">× ×¡×” ×©×•×‘</button>
            <button class="reset-btn" onclick="resetGameData()">××™×¤×•×¡ ×”×ª×§×“××•×ª</button>
        </div>
        
        <div id="stageComplete">
            <h2>ğŸ‰ ×›×œ ×”×›×‘×•×“! ×¢×‘×¨×ª ××ª ×”×©×œ×‘! ğŸ‰</h2>
            <p>×©×œ×‘ <span id="completedStage">1</span> - <span id="completedStageName">×”×ª×—×œ×”</span> ×”×•×©×œ×!</p>
            
            <div style="background: rgba(76,175,80,0.2); padding: 15px; border-radius: 10px; margin: 15px 0;">
                <h3>ğŸ“Š ×¡×˜×˜×™×¡×˜×™×§×•×ª ×”×©×œ×‘:</h3>
                <p>ğŸ¯ × ×™×§×•×“ ×”×©×œ×‘: <span id="stageScore">0</span> × ×§×•×“×•×ª</p>
                <p>â±ï¸ ×–××Ÿ ×”×©×œ×‘: <span id="stageTime">0</span> ×©× ×™×•×ª</p>
                <p>ğŸ”¥ ×§×•××‘×• ××§×¡×™××œ×™: <span id="stageMaxCombo">1</span></p>
                <p>â­ ×›×•×›×‘×™× ×©× ×ª×¤×¡×•: <span id="starsCaught">0</span></p>
                <p>ğŸ’¥ ×¤×¦×¦×•×ª ×©× ×× ×¢×•: <span id="bombsAvoided">0</span></p>
                <p>ğŸ•³ï¸ ×—×•×¨×™× ×©×—×•×¨×™× ×©× ×× ×¢×•: <span id="blackholesAvoided">0</span></p>
                <p>âš¡ ×‘×¨×§×™× ×©× ×× ×¢×•: <span id="lightningAvoided">0</span></p>
            </div>
            
            <div style="background: rgba(255,152,0,0.2); padding: 15px; border-radius: 10px; margin: 15px 0;">
                <h3>ğŸ“ˆ ×”×ª×§×“××•×ª ×‘×¨××” ×”×’×œ×•×‘×œ×™×ª:</h3>
                <p>ğŸ“Š ×¡×”"×› × ×§×•×“×•×ª ×‘×¨××”: <span id="levelScore">0</span></p>
                <p>ğŸ® ×©×œ×‘×™× ×©×”×•×©×œ××•: <span id="completedStages">0</span>/20</p>
                <div style="width: 100%; background: rgba(0,0,0,0.3); border-radius: 10px; height: 20px; margin: 10px 0;">
                    <div id="levelProgressFill" style="height: 100%; background: linear-gradient(90deg, #ff9800, #ffc107); border-radius: 10px; transition: width 0.3s; position: relative;">
                        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 12px; font-weight: bold; color: white; text-shadow: 1px 1px 2px rgba(0,0,0,0.8);" id="levelProgressText"></div>
                    </div>
                </div>
            </div>
            
            <div style="display: flex; gap: 10px; justify-content: center; margin-top: 20px;">
                <button onclick="nextStage()" style="background: linear-gradient(45deg, #4caf50, #8bc34a); font-size: 18px; padding: 15px 30px;">
                    <span id="nextStageText">×©×œ×‘ ×”×‘× â†’</span>
                </button>
                <button onclick="retryStage()" class="retry-btn">× ×¡×” ×©×œ×‘ ×–×” ×©×•×‘</button>
            </div>
        </div>
        
        <div id="levelComplete">
            <h2>ğŸ‰ ××–×œ ×˜×•×‘! ×¢×œ×™×ª ×¨××” ×’×œ×•×‘×œ×™×ª! ğŸ‰</h2>
            <p>×¡×™×™××ª ×¨××” <span id="completedLevel">1</span>!</p>
            <p>×¢×œ×™×ª ×œ×¨××” <span id="newLevel">2</span>!</p>
            <p>××›×¤×™×œ ×—×“×©: x<span id="newMultiplier">2</span></p>
            <p>×¤××•×•×¨-××¤×™× ×—×“×©×™× × ×¤×ª×—×•!</p>
            <button class="mega-btn" onclick="nextLevel()">×”×ª×—×œ ×¨××” ×—×“×©×”!</button>
        </div>
    </div>

    <script>
let globalLevel = 1;
let currentStage = 1;
let score = 0;
let levelScore = 0;
let lives = 3;
let gameRunning = false;
let starSpeed = 2;
let spawnRate = 0.025;
let bombChance = 0.1;
let combo = 1;
let comboCount = 0;
let firstMove = false;
let saveInterval = null;
let maxCombo = 1;
let shieldTime = 0;
let speedBoostTime = 0;
let freezeTime = 0;
let magnetTime = 0;
let doublePointsTime = 0;
let lastStarType = null;
let stageStartTime = 0;

// Stage stats
let starsCaught = 0;
let bombsAvoided = 0;
let blackholesAvoided = 0;
let lightningAvoided = 0;

// Level stats
let levelStarsCaught = 0;

let gameInterval;
let timerInterval;

const baseStageTargets = [
    100, 150, 200, 280, 370, 480, 600, 750, 920, 1120,
    1350, 1620, 1930, 2280, 2670, 3100, 3570, 4080, 4630, 5220
];

const stageNames = [
    "×”×ª×—×œ×”", "×¦×¢×“×™× ×¨××©×•× ×™×", "××ª×¨×’×œ", "××‘×™×Ÿ", "××ª××™×“", 
    "××ª×—××", "××ª×§×“×", "×××ª×’×¨", "×§×©×”", "××•×¨×›×‘",
    "××§×¦×•×¢×™", "××•××—×”", "×××Ÿ", "×•×™×¨×˜×•××•×–", "×’××•×Ÿ",
    "××“×”×™×", "××’×“×™", "×‘×œ×ª×™ ×™×ª×•××¨", "×¢×œ ×× ×•×©×™", "××•×©×œ×"
];

const baseStarTypes = [
    { emoji: 'â­', basePoints: 5, chance: 0.4, class: 'star-regular' },
    { emoji: 'ğŸŒŸ', basePoints: 10, chance: 0.3, class: 'star-blue' },
    { emoji: 'ğŸ’«', basePoints: 20, chance: 0.15, class: 'star-silver' },
    { emoji: 'ğŸŒ ', basePoints: 50, chance: 0.08, class: 'star-gold' },
    { emoji: 'ğŸ†', basePoints: 100, chance: 0.02, class: 'star-rainbow' }
];

const powerupTypes = [
    { emoji: 'ğŸ›¡ï¸', type: 'shield', chance: 0.04, minLevel: 1 },
    { emoji: 'â¤ï¸', type: 'life', chance: 0.03, minLevel: 1 },
    { emoji: 'âš¡', type: 'speed', chance: 0.04, minLevel: 1 },
    { emoji: 'â„ï¸', type: 'freeze', chance: 0.02, minLevel: 2 },
    { emoji: 'ğŸ§²', type: 'magnet', chance: 0.02, minLevel: 3 },
    { emoji: 'ğŸ’', type: 'double', chance: 0.02, minLevel: 4 }
];

const gameContainer = document.getElementById('gameContainer');
const player = document.getElementById('player');

let mouseX = 200;
let mouseY = 200;

// ===================== ×¢×–×¨×™ Cookie ×™×¦×™×‘×™× =====================
function setCookie(name, value, days) {
    try {
        const json = JSON.stringify(value);
        const d = new Date();
        d.setTime(d.getTime() + (days * 24 * 60 * 60 * 1000));
        const expires = "expires=" + d.toUTCString();
        document.cookie = `${name}=${encodeURIComponent(json)};${expires};path=/;SameSite=Lax`;
    } catch (e) {
        console.error('setCookie error:', e);
    }
}

function getCookie(name) {
    try {
        const cookieName = name + "=";
        const decoded = decodeURIComponent(document.cookie || "");
        const parts = decoded.split(';');
        for (let c of parts) {
            c = c.trim();
            if (c.indexOf(cookieName) === 0) {
                const raw = c.substring(cookieName.length);
                try {
                    return JSON.parse(raw);
                } catch (e) {
                    console.warn('Cookie JSON parse failed, clearing cookie', e);
                    deleteCookie(name);
                    return null;
                }
            }
        }
        return null;
    } catch (e) {
        console.error('getCookie error:', e);
        return null;
    }
}

function deleteCookie(name) {
    document.cookie = `${name}=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/; SameSite=Lax`;
}

// ×©× ×§×‘×•×¢ ×œ××¦×‘ ×”××©×—×§
const GAME_COOKIE = 'catchTheStarGameState';

// ===================== ×©××™×¨×”/×˜×¢×™× ×” =====================
function saveGame() {
    const gameState = {
        version: 1,
        globalLevel,
        currentStage,
        score,
        levelScore,
        lives
        // ×œ× × ×©××¨×™× ×˜×™×™××¨×™× ×–×× ×™×™× ×›×“×™ ×œ× ×œ×©×—×–×¨ ××¤×§×˜×™× ×©×—×•×œ×¤×™×
    };
    setCookie(GAME_COOKIE, gameState, 30);
}

function autoSaveGame() {
    saveGame();
}

function loadGame() {
    const saved = getCookie(GAME_COOKIE);
    if (!saved || typeof saved !== 'object') return false;

    const lvl = Number(saved.globalLevel) || 1;
    const stg = Number(saved.currentStage) || 1;
    const sc = Number(saved.score) || 0;
    const lvlSc = Number(saved.levelScore) || 0;
    const lv = Number(saved.lives);
    const livesVal = Number.isFinite(lv) ? Math.max(0, Math.min(5, lv)) : 3;

    globalLevel = Math.max(1, lvl);
    currentStage = Math.max(1, Math.min(20, stg));
    score = Math.max(0, sc);
    levelScore = Math.max(0, lvlSc);
    lives = livesVal;

    return true;
}

// ×›×¤×ª×•×¨ ××™×¤×•×¡ ××ª×§×“×
function resetGameData() {
    const ok = confirm('×”×× ×œ××¤×¡ ××ª ×›×œ ×”×”×ª×§×“××•×ª?');
    if (!ok) return;
    deleteCookie(GAME_COOKIE);
    globalLevel = 1;
    currentStage = 1;
    score = 0;
    levelScore = 0;
    lives = 3;
    combo = 1;
    updateAllUI();
    saveGame();
    startStage(1);
}

// ===================== ×¢×–×¨×™ UI =====================
function updatePlayerPosition(clientX, clientY) {
    if (!gameRunning) return;
    const rect = gameContainer.getBoundingClientRect();
    mouseX = clientX - rect.left;
    mouseY = clientY - rect.top;
    mouseX = Math.max(20, Math.min(rect.width - 20, mouseX));
    mouseY = Math.max(20, Math.min(rect.height - 20, mouseY));
    player.style.left = (mouseX - 20) + 'px';
    player.style.top = (mouseY - 20) + 'px';
}

gameContainer.addEventListener('mousemove', (e) => updatePlayerPosition(e.clientX, e.clientY));
gameContainer.addEventListener('touchmove', (e) => {
    e.preventDefault();
    if (e.touches.length > 0) updatePlayerPosition(e.touches[0].clientX, e.touches[0].clientY);
});
gameContainer.addEventListener('touchstart', (e) => {
    e.preventDefault();
    if (e.touches.length > 0) updatePlayerPosition(e.touches[0].clientX, e.touches[0].clientY);
});

function getStarTypes() {
    return baseStarTypes.map(star => ({
        ...star,
        points: Math.floor(star.basePoints * globalLevel * (doublePointsTime > 0 ? 2 : 1))
    }));
}

function getRandomStarType() {
    const starTypes = getStarTypes();
    const random = Math.random();
    let cumulative = 0;
    for (let type of starTypes) {
        cumulative += type.chance;
        if (random < cumulative) return type;
    }
    return starTypes[0];
}

function getRandomPowerup() {
    const availablePowerups = powerupTypes.filter(p => globalLevel >= p.minLevel);
    if (availablePowerups.length === 0) return null;
    const totalChance = availablePowerups.reduce((sum, p) => sum + p.chance, 0);
    const random = Math.random() * totalChance;
    let cumulative = 0;
    for (let powerup of availablePowerups) {
        cumulative += powerup.chance;
        if (random < cumulative) return powerup;
    }
    return null;
}

function showFloatingText(x, y, text, className) {
    const element = document.createElement('div');
    element.className = className;
    element.textContent = text;
    element.style.left = x + 'px';
    element.style.top = y + 'px';
    gameContainer.appendChild(element);
    setTimeout(() => {
        if (element.parentNode) element.remove();
    }, 1000);
}

function createFallingObject() {
    if (!gameRunning) return;
    const random = Math.random();
    const object = document.createElement('div');
    let objectType = 'star';

    const totalThreatChance = bombChance * 1.5;
    const bombChanceActual = bombChance * 0.6;
    const blackholeChance = bombChance * 0.25;

    if (random < totalThreatChance) {
        const threatRandom = Math.random();
        if (threatRandom < (bombChanceActual / totalThreatChance)) {
            objectType = 'bomb';
            object.className = 'bomb';
            object.textContent = 'ğŸ’¥';
        } else if (threatRandom < ((bombChanceActual + blackholeChance) / totalThreatChance)) {
            objectType = 'blackhole';
            object.className = 'blackhole';
            object.textContent = 'ğŸ•³ï¸';
            object.dataset.pullRadius = '80';
        } else {
            objectType = 'lightning';
            object.className = 'lightning';
            object.textContent = 'â›ˆï¸';
            object.dataset.speed = Math.random() > 0.5 ? 'fast' : 'normal';
        }
    } else {
        const powerupMultiplier = Math.min(globalLevel, 3);
        const powerupCheck = Math.random();
        const powerup = getRandomPowerup();
        if (powerup && powerupCheck < (0.08 * powerupMultiplier)) {
            objectType = 'powerup';
            object.className = 'powerup';
            object.textContent = powerup.emoji;
            object.dataset.powerupType = powerup.type;
        } else {
            const starType = getRandomStarType();
            object.className = `star ${starType.class}`;
            object.textContent = starType.emoji;
            object.dataset.points = starType.points;
            object.dataset.starType = starType.emoji;
            objectType = 'star';
        }
    }

    const containerRect = gameContainer.getBoundingClientRect();
    object.style.left = Math.random() * (containerRect.width - 40) + 'px';
    object.style.top = '-40px';
    gameContainer.appendChild(object);

    if (magnetTime > 0 && objectType === 'star') {
        object.dataset.magnetic = 'true';
    }

    function fall() {
        if (!gameRunning || !object.parentNode) {
            if (object.parentNode) object.remove();
            return;
        }

        const currentTop = parseInt(object.style.top) || 0;
        let fallSpeed = speedBoostTime > 0 ? starSpeed * 1.5 : starSpeed;
        if (freezeTime > 0) fallSpeed *= 0.3;
        if (objectType === 'lightning' && object.dataset.speed === 'fast') fallSpeed *= 1.5;

        if (objectType === 'blackhole') {
            const pullRadius = parseInt(object.dataset.pullRadius) || 80;
            const blackholeX = parseInt(object.style.left) + 15;
            const blackholeY = parseInt(object.style.top) + 15;
            const playerDistance = Math.sqrt(Math.pow(mouseX - blackholeX, 2) + Math.pow(mouseY - blackholeY, 2));
            if (playerDistance < pullRadius) {
                const pullStrength = (pullRadius - playerDistance) / pullRadius * 0.8;
                mouseX += (blackholeX - mouseX) * pullStrength;
                mouseY += (blackholeY - mouseY) * pullStrength;
                const containerRect = gameContainer.getBoundingClientRect();
                mouseX = Math.max(20, Math.min(containerRect.width - 20, mouseX));
                mouseY = Math.max(20, Math.min(containerRect.height - 20, mouseY));
                player.style.left = (mouseX - 20) + 'px';
                player.style.top = (mouseY - 20) + 'px';
            }
        }

        if (object.dataset.magnetic === 'true') {
            const currentLeft = parseInt(object.style.left) || 0;
            object.style.left = (currentLeft + ((mouseX - 20) - currentLeft) * 0.03) + 'px';
        }

        object.style.top = (currentTop + fallSpeed) + 'px';

        const objectRect = object.getBoundingClientRect();
        const playerRect = player.getBoundingClientRect();

        if (objectRect.left < playerRect.right &&
            objectRect.right > playerRect.left &&
            objectRect.top < playerRect.bottom &&
            objectRect.bottom > playerRect.top) {
            handleCollision(object, objectType);
            return;
        }

        const contRect = gameContainer.getBoundingClientRect();
        if (currentTop > contRect.height) {
            if (object.parentNode) object.remove();
            if (objectType === 'star') resetCombo();
            return;
        }
        requestAnimationFrame(fall);
    }
    requestAnimationFrame(fall);
}

function handleCollision(object, objectType) {
    const rect = object.getBoundingClientRect();
    const gameRect = gameContainer.getBoundingClientRect();
    const x = rect.left - gameRect.left;
    const y = rect.top - gameRect.top;

    if (objectType === 'bomb') {
        if (shieldTime > 0) {
            bombsAvoided++;
            showFloatingText(x, y, '×—×¡×•×!', 'combo-text');
        } else {
            lives--;
            updateLives();
            showFloatingText(x, y, '×‘×•×!', 'points-text');
            resetCombo();
            if (lives <= 0) endStage(false);
        }
    } else if (objectType === 'blackhole') {
        if (shieldTime > 0) {
            blackholesAvoided++;
            showFloatingText(x, y, '××’×Ÿ ××—×•×¨!', 'combo-text');
        } else {
            lives -= 2;
            updateLives();
            showFloatingText(x, y, '× ×‘×œ×¢!', 'points-text');
            resetCombo();
            speedBoostTime = freezeTime = magnetTime = doublePointsTime = 0;
            if (lives <= 0) endStage(false);
        }
    } else if (objectType === 'lightning') {
        if (shieldTime > 0) {
            lightningAvoided++;
            showFloatingText(x, y, '×”×’× ×”!', 'combo-text');
        } else {
            speedBoostTime = freezeTime = 0;
            const contRect = gameContainer.getBoundingClientRect();
            mouseX = Math.random() * (contRect.width - 40) + 20;
            mouseY = Math.random() * (contRect.height - 40) + 20;
            player.style.left = (mouseX - 20) + 'px';
            player.style.top = (mouseY - 20) + 'px';
            showFloatingText(x, y, '×–×¢×–×•×¢!', 'points-text');
            resetCombo();
        }
    } else if (objectType === 'powerup') {
        handlePowerup(object.dataset.powerupType, x, y);
    } else if (objectType === 'star') {
        starsCaught++;
        levelStarsCaught++;
        let points = parseInt(object.dataset.points) * combo;
        score += points;
        levelScore += points;
        updateScore();
        updateProgress();
        const target = getStageTarget(currentStage, globalLevel);
        if (score >= target) {
            endStage(true);
            return;
        }
        if (lastStarType === object.dataset.starType) {
            comboCount++;
            if (comboCount >= 2) {
                combo = Math.min(combo + 1, 5);
                maxCombo = Math.max(maxCombo, combo);
                updateCombo();
                showFloatingText(x, y, `×§×•××‘×• x${combo}!`, 'combo-text');
            }
        } else {
            comboCount = 1;
            combo = Math.max(combo - 1, 1);
            updateCombo();
        }
        lastStarType = object.dataset.starType;
        showFloatingText(x, y, `+${points}`, 'points-text');
    }

    if (object.parentNode) object.remove();
}

function handlePowerup(type, x, y) {
    switch(type) {
        case 'shield':
            shieldTime = 600; // 10s
            player.classList.add('player-shield');
            showFloatingText(x, y, '××’×Ÿ!', 'combo-text');
            break;
        case 'life':
            lives = Math.min(lives + 1, 5);
            updateLives();
            showFloatingText(x, y, '×—×™×™×!', 'combo-text');
            break;
        case 'speed':
            speedBoostTime = 480; // 8s
            showFloatingText(x, y, '××”×™×¨×•×ª!', 'combo-text');
            break;
        case 'freeze':
            freezeTime = 300; // 5s
            showFloatingText(x, y, '×”×§×¤××”!', 'combo-text');
            break;
        case 'magnet':
            magnetTime = 420; // 7s
            showFloatingText(x, y, '××’× ×˜!', 'combo-text');
            break;
        case 'double':
            doublePointsTime = 420; // 7s
            showFloatingText(x, y, '× ×§×•×“×•×ª x2!', 'combo-text');
            break;
    }
}

function resetCombo() {
    combo = 1;
    comboCount = 0;
    lastStarType = null;
    updateCombo();
}

function updateScore() {
    document.getElementById('score').textContent = score;
}

function updateLives() {
    document.getElementById('lives').textContent = Math.max(0, lives);
}

function updateCombo() {
    document.getElementById('combo').textContent = 'x' + combo;
}

function getStageTarget(stage, level) {
    const idx = Math.max(1, Math.min(20, stage)) - 1;
    return Math.floor(baseStageTargets[idx] * Math.max(1, level));
}

function updateProgress() {
    const target = getStageTarget(currentStage, globalLevel);
    const progress = Math.min((score / target) * 100, 100);
    document.getElementById('progressFill').style.width = progress + '%';
    document.getElementById('progressText').textContent = `${score} / ${target}`;
}

function updatePowerupTimers() {
    if (shieldTime > 0) { shieldTime--; if (shieldTime === 0) player.classList.remove('player-shield'); }
    if (speedBoostTime > 0) speedBoostTime--;
    if (freezeTime > 0) freezeTime--;
    if (magnetTime > 0) magnetTime--;
    if (doublePointsTime > 0) doublePointsTime--;
    updateSpecialStatus();
}

function updateSpecialStatus() {
    let specialText = '';
    if (shieldTime > 0) specialText += `ğŸ›¡ï¸(${Math.ceil(shieldTime / 60)}) `;
    if (speedBoostTime > 0) specialText += `âš¡(${Math.ceil(speedBoostTime / 60)}) `;
    if (freezeTime > 0) specialText += `â„ï¸(${Math.ceil(freezeTime / 60)}) `;
    if (magnetTime > 0) specialText += `ğŸ§²(${Math.ceil(magnetTime / 60)}) `;
    if (doublePointsTime > 0) specialText += `ğŸ’(${Math.ceil(doublePointsTime / 60)}) `;
    document.getElementById('special').textContent = specialText.trim() || '××™×Ÿ';
}

function updateLegends() {
    document.getElementById('freezeLegend').style.opacity = globalLevel >= 2 ? '1' : '0.5';
    document.getElementById('magnetLegend').style.opacity = globalLevel >= 3 ? '1' : '0.5';
    document.getElementById('doubleLegend').style.opacity = globalLevel >= 4 ? '1' : '0.5';
}

function gameLoop() {
    if (Math.random() < spawnRate) {
        createFallingObject();
    }
}

function clearObjects() {
    const objects = document.querySelectorAll('.star, .bomb, .blackhole, .lightning, .powerup, .points-text, .combo-text');
    objects.forEach(obj => obj.remove());
}

// ===================== UI ××¨×•×›×– =====================
function updateAllUI() {
    document.getElementById('globalLevel').textContent = `×¨××” ×’×œ×•×‘×œ×™×ª: ${globalLevel} (××›×¤×™×œ × ×§×•×“×•×ª: x${globalLevel})`;
    updateLegends();

    const idx = Math.max(1, Math.min(20, currentStage)) - 1;
    const name = stageNames[idx];
    const target = getStageTarget(currentStage, globalLevel);

    document.getElementById('stageTitle').textContent = `×©×œ×‘ ${currentStage}: ${name}`;
    document.getElementById('stageGoal').textContent = `×™×¢×“: ${target} × ×§×•×“×•×ª`;
    document.getElementById('stageNum').textContent = `${currentStage}/20`;

    updateScore();
    updateLives();
    updateCombo();
    updateProgress();
    updateSpecialStatus();
}

// ===================== ×œ×•×’×™×§×ª ×©×œ×‘×™× =====================
function startStage(stage) {
    currentStage = Math.max(1, Math.min(20, stage));
    // ×× ×¨×•×¦×™× ×œ×”×ª×—×™×œ ×›×œ ×©×œ×‘ ×× ×™×§×•×“ 0: ×”×©×•×¨×” ×”×‘××” ×××¤×¡×ª
    score = 0;

    combo = 1;
    maxCombo = 1;
    comboCount = 0;
    shieldTime = speedBoostTime = freezeTime = magnetTime = doublePointsTime = 0;
    starsCaught = bombsAvoided = blackholesAvoided = lightningAvoided = 0;
    stageStartTime = Date.now();

    // ×§×•×©×™
    starSpeed = 2 + (currentStage * 0.1) + (globalLevel * 0.2);
    spawnRate = 0.025 + (currentStage * 0.001) + (globalLevel * 0.002);
    bombChance = 0.1 + (currentStage * 0.005) + (globalLevel * 0.01);

    document.getElementById('gameOver').style.display = 'none';
    document.getElementById('stageComplete').style.display = 'none';
    document.getElementById('levelComplete').style.display = 'none';

    updateAllUI();
    clearObjects();

    gameRunning = true;
    gameInterval = setInterval(gameLoop, 16); // ~60fps
    timerInterval = setInterval(updatePowerupTimers, 1000 / 60);

    // ×©××•×¨ ××™×“ ××—×¨×™ ×”×ª×—×œ×ª ×”×©×œ×‘
    saveGame();
}

function endStage(success) {
    gameRunning = false;
    clearInterval(gameInterval);
    clearInterval(timerInterval);
    clearObjects();

    if (success) {
        const stageTime = ((Date.now() - stageStartTime) / 1000).toFixed(1);
        const idx = Math.max(1, Math.min(20, currentStage)) - 1;

        document.getElementById('completedStage').textContent = currentStage;
        document.getElementById('completedStageName').textContent = stageNames[idx];
        document.getElementById('stageScore').textContent = score;
        document.getElementById('stageTime').textContent = stageTime;
        document.getElementById('stageMaxCombo').textContent = 'x' + maxCombo;
        document.getElementById('starsCaught').textContent = starsCaught;
        document.getElementById('bombsAvoided').textContent = bombsAvoided;
        document.getElementById('blackholesAvoided').textContent = blackholesAvoided;
        document.getElementById('lightningAvoided').textContent = lightningAvoided;

        document.getElementById('levelScore').textContent = levelScore;
        document.getElementById('completedStages').textContent = `${currentStage}/20`;

        const levelProgress = Math.min((currentStage / 20) * 100, 100);
        document.getElementById('levelProgressFill').style.width = levelProgress + '%';
        document.getElementById('levelProgressText').textContent = `${currentStage}/20`;

        if (currentStage >= 20) {
            document.getElementById('nextStageText').textContent = '×¡×™×™× ×¨××”!';
        } else {
            document.getElementById('nextStageText').textContent = '×©×œ×‘ ×”×‘× â†’';
        }

        document.getElementById('stageComplete').style.display = 'block';
        saveGame();
    } else {
        const target = getStageTarget(currentStage, globalLevel);
        document.getElementById('failScore').textContent = score;
        document.getElementById('failTarget').textContent = target;
        document.getElementById('gameOver').style.display = 'block';
        saveGame();
    }
}

function checkLevelUp() {
    if (currentStage >= 20) {
        document.getElementById('stageComplete').style.display = 'none';

        document.getElementById('completedLevel').textContent = globalLevel;
        document.getElementById('newLevel').textContent = globalLevel + 1;
        document.getElementById('newMultiplier').textContent = globalLevel + 1;

        globalLevel++;
        levelScore = 0;
        levelStarsCaught = 0;

        document.getElementById('globalLevel').textContent = `×¨××” ×’×œ×•×‘×œ×™×ª: ${globalLevel} (××›×¤×™×œ × ×§×•×“×•×ª: x${globalLevel})`;
        updateLegends();
        saveGame();

        document.getElementById('levelComplete').style.display = 'block';
    } else {
        nextStage();
    }
}

function nextStage() {
    if (currentStage >= 20) {
        checkLevelUp();
    } else {
        currentStage++;
        saveGame();
        startStage(currentStage);
    }
}

function retryStage() {
    lives = Math.max(lives, 1);
    updateLives();
    saveGame();
    startStage(currentStage);
}

function restartGame() {
    globalLevel = 1;
    currentStage = 1;
    lives = 3;
    levelScore = 0;
    saveGame();
    startStage(1);
}

function nextLevel() {
    currentStage = 1;
    saveGame();
    startStage(1);
}

// ===================== ××ª×—×•×œ ××•×§×“× ×•×‘×˜×•×— =====================
document.addEventListener('DOMContentLoaded', () => {
    loadGame();         // ×˜×¢×Ÿ ×§×•×“×
    updateAllUI();      // ×¢×“×›×Ÿ UI ××”××¦×‘ ×”×˜×¢×•×Ÿ/×‘×¨×™×¨×ª ××—×“×œ
    startStage(currentStage); // ×”×ª×—×œ ×©×œ×‘ ×¨×§ ××—×¨×™ ×˜×¢×™× ×”

    // ×©××™×¨×” ××•×˜×•××˜×™×ª ×›×œ 5 ×©× ×™×•×ª
    if (!saveInterval) {
        saveInterval = setInterval(autoSaveGame, 5000);
    }
});

// ×©××™×¨×” ×œ×¤× ×™ ×™×¦×™××”/×¨×¢× ×•×Ÿ
window.addEventListener('beforeunload', () => {
    try { saveGame(); } catch(e) {}
});

// ×©××™×¨×” ×’× ××—×¨×™ ××™× ×˜×¨××§×¦×™×” ×¨××©×•× ×” (×œ×™×ª×¨ ×‘×™×˜×—×•×Ÿ)
window.addEventListener("mousemove", () => {
    if (!firstMove) {
        firstMove = true;
        saveGame();
    }
});

// ×—×©×™×¤×” ×¢×‘×•×¨ ×›×¤×ª×•×¨×™× ×‘-HTML
window.resetGameData = resetGameData;
window.retryStage = retryStage;
window.nextStage = nextStage;
window.nextLevel = nextLevel;

    </script>
</body>
</html>